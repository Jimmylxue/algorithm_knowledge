/**

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: nums = [2,3,0,1,4]
输出: 2

 */

/**
 * 这题使用的是贪心算法，一个元素最大可以走的距离是它的元素大小
 *  而最小可以走的距离是1
 *  在最差的一个情况下，走到头要走它 数组长度-1 次
 *  在比较好的情况下  是走到数组的元素的大小刚好就可以走完
 *  所以基于这个 可以写出类似贪心算法的解题方法
 *
 *  遍历这个数组，只需要遍历到 数组长度-1 那个为最开始就可以，因为我们最早
 *  是在数组的第一个元素上
 *
 * 所以每次我们都判断  在一个位置上  最多能走到多远的距离， 以这个为基准进行往后
 * 一直循环执行下去。
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function (nums) {
  let curIndex = 0;
  let nextIndex = 0;
  let steps = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    nextIndex = Math.max(nums[i] + i, nextIndex);
    if (i === curIndex) {
      curIndex = nextIndex;
      steps++;
    }
  }

  return steps;
};
console.log(jump([2, 1]));
